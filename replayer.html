<html>
   <head>
      <meta charset='UTF-8'>
      <script src='../canvas-rr/rr-replay.js'></script>
      <script src='gl-2d.js'></script>
   </head>
   <body>
Recording: <input id='fileInput' type='file' accept='.json'
                  onchange='file_input_changed(this.files[0])'/>
<br/>
Status: <span id='e_status'>-</span>

<hr/>
<button onclick='reset_button()'>Reset</button>
<button onclick='play_button()'>Play</button>
<button onclick='loop_button()'>Loop</button>
<hr/>
<div id='e_sandbox'></div>
<script>

let RECORDING = null;

async function file_input_changed(blob) {
   const start = performance.now();
   let last_split = start;

   function log_split(text) {
      let split = performance.now();
      const split_diff = split - last_split;
      const total_diff = split - start;
      console.log(`[${split_diff|0}/${total_diff|0}ms]`, text);
   }

   e_status.textContent = 'Reading...';
   const text = await blob.text();
   log_split(`Read ${text.length} bytes.`);

   e_status.textContent = 'Parsing...';
   const json = JSON.parse(text);
   log_split('Parsed.');

   e_status.textContent = 'Loading...';
   RECORDING = await Recording.from_json(json);
   log_split(`Loaded ${RECORDING.frames.length} frames.`);

   e_status.textContent = 'Ready.';
}

function remove_all_children(elem) {
   while (elem.firstChild) {
      elem.removeChild(elem.firstChild);
   }
}

let NEXT_LOOP_FRAME = undefined;

function reset_button() {
   NEXT_LOOP_FRAME = undefined;
   remove_all_children(e_sandbox);

   const elem_map = RECORDING.make_elems();
   RECORDING.elem_map = elem_map;

   for (const k in elem_map) {
      const elem = elem_map[k];
      if (elem.constructor.name !== 'HTMLCanvasElement') continue;

      const e_elem_title = document.createElement('div');
      e_elem_title.textContent = k + ':';
      e_sandbox.appendChild(e_elem_title);

      elem.style.border = '1px solid black';
      e_sandbox.appendChild(elem);
   }
}

function play_button() {
   reset_button();
   RECORDING.play(RECORDING.elem_map, 0);
}

// -

(function() {
   if (window.setImmediate) return;

   let next_id = 1;
   let func_by_id = {};
   const KEY = 'window.setImmediate';
   function handler(e) {
      if (e.data !== KEY) return;
      e.stopImmediatePropagation();

      for (const func of Object.values(func_by_id)) {
         (async function() {
            func();
         })();
      }
      func_by_id = {};
   }
   window.addEventListener('message', handler, true);

   window.setImmediate = function(func) {
      const id = next_id;
      next_id += 1;
      func_by_id[id] = func;
      window.postMessage(KEY, '*');
      return id;
   };

   window.clearImmediate = function(id) {
      func_by_id[id] = undefined;
   };
})();

function next_event_loop() {
   return new Promise((res, rej) => {
      setImmediate(() => {
         res();
      });
   });
}

// -

function loop_button() {
   reset_button();
   NEXT_LOOP_FRAME = 0;
}

async function on_raf() {
   await next_event_loop();
   requestAnimationFrame(on_raf);
   if (NEXT_LOOP_FRAME === undefined) return;

   // -

   const frame = NEXT_LOOP_FRAME;
   NEXT_LOOP_FRAME += 1;
   NEXT_LOOP_FRAME %= RECORDING.frames.length;

   RECORDING.play(RECORDING.elem_map, frame, frame+1);
}
on_raf();

</script>
   </body>
</html>
